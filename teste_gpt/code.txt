#include <iostream>
#include <cmath>

const float EPSILON = 0.0001f;

struct Vector3 {
  float x, y, z;
};

struct RigidBody {
  Vector3 position;
  Vector3 velocity;
  Vector3 acceleration;
  float inverseMass;
  Vector3 forceAccum;

  void clearAccumulator() {
    forceAccum = {0, 0, 0};
  }

  void addForce(const Vector3 &force) {
    forceAccum.x += force.x;
    forceAccum.y += force.y;
    forceAccum.z += force.z;
  }

  void integrate(float deltaTime) {
    velocity.x += acceleration.x * deltaTime;
    velocity.y += acceleration.y * deltaTime;
    velocity.z += acceleration.z * deltaTime;

    position.x += velocity.x * deltaTime;
    position.y += velocity.y * deltaTime;
    position.z += velocity.z * deltaTime;

    clearAccumulator();
  }
};

bool checkCollision(const RigidBody &a, const RigidBody &b) {
  Vector3 relativeVelocity = {
    b.velocity.x - a.velocity.x,
    b.velocity.y - a.velocity.y,
    b.velocity.z - a.velocity.z
  };

  Vector3 relativePosition = {
    b.position.x - a.position.x,
    b.position.y - a.position.y,
    b.position.z - a.position.z
  };

  float distance = std::sqrt(
    relativePosition.x * relativePosition.x +
    relativePosition.y * relativePosition.y +
    relativePosition.z * relativePosition.z
  );

  float velocityAlongNormal = relativeVelocity.x * relativePosition.x +
                              relativeVelocity.y * relativePosition.y +
                              relativeVelocity.z * relativePosition.z;

  if (distance < EPSILON && velocityAlongNormal < 0) {
    float impulse = 2.0f * a.inverseMass * b.inverseMass / (a.inverseMass + b.inverseMass);
    Vector3 impulsePerIMass = {
      impulse * relativePosition.x / distance,
      impulse * relativePosition.y / distance,
      impulse * relativePosition.z / distance
    };

    a.velocity.x -= impulsePerIMass.x * a.inverseMass;
    a.velocity.y -= impulsePerIMass.y * a.inverseMass;
    a.velocity.z -= impulsePerIMass.z * a.inverseMass;

    b.velocity.x += impulsePerIMass.x * b.inverseMass;
    b.velocity.y += impulsePerIMass.y * b.inverseMass;
    b.velocity.z += impulsePerIMass.z * b.inverseMass;

    return true;
  }

  return
