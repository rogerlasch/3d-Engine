#16
Frio
2024-03-26 05:28:28
Tons de novato
Desligado
Registrado: 2021-11-13
Postagens: 19
Karma do usuário: 2
OK, então havia muitas coisas muito erradas com a implementação no meu comentário anterior. Ele passou nos testes, mas parte do código nunca foi executado quando deveria, e depois de investigar o porquê, percebi que estava longe de ser uma implementação GJK adequada. Meu teste para verificar se um segmento passa pela origem estava errado, meu teste para verificar se a origem está contida no simplex estava muito errado, minha resposta para quando um simplex não contém a origem estava errada, mas eu ainda gostaria de entender como o código funcionava, porque eu poderia ter encontrado uma otimização dado o quão pouco ele teve que computar para passar em todos os testes, ou isso ou eu tive muito azar.
Abaixo segue o que eu acho ser a implementação correta junto com sua saída, com alguns comentários já que certas coisas podem não ser muito óbvias:
import math

class Vector:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    
    def __repr__(self):
        return "[x: %.02f, y: %.02f, z: %.02f]" % (self.x, self.y, self.z)
    
    def __eq__(self, other):
        if (math.isnan(self.x) or math.isnan(self.y) or math.isnan(self.z)) and (math.isnan(other.x) or math.isnan(other.y) or math.isnan(other.z)):
            return True
        diff = self - other
        return abs(diff.x) < epsilon and abs(diff.y) < epsilon and abs(diff.z) < epsilon
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)
    
    def __mul__(self, other):
        if isinstance(other, float):
            return Vector(self.x * other, self.y * other, self.z * other)
        return Vector(self.x * other.x, self.y * other.y, self.z * other.z)
    
    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y, self.z - other.z)
    
    def __truediv__(self, other):
        if isinstance(other, float):
            return Vector(self.x / other, self.y / other, self.z / other)
        return Vector(self.x / other.x, self.y / other.y, self.z / other.z)
    
    def __neg__(self):
        return Vector(-self.x, -self.y, -self.z)
    
    def dot(self, other):
        return self.x * other.x + self.y * other.y + self.z * other.z
    
    def cross(self, other):
        return Vector(self.y * other.z - self.z * other.y, self.z * other.x - self.x * other.z, self.x * other.y - self.y * other.x)
    
    def square_length(self):
        return self.dot(self)
    
    def length(self):
        return math.sqrt(self.square_length())

Vector.ORIGIN = Vector(0.0, 0.0, 0.0)

class Quaternion:
    def __init__(self, vector, scalar):
        self.vector = vector
        self.scalar = scalar
    
    def __mul__(self, other):
        if isinstance(other, Vector):
            conj = Quaternion(-self.vector, self.scalar)
            vec = Quaternion(other, 0.0)
            quat = self * vec * conj
            return quat.vector
        return Quaternion(self.vector.cross(other.vector) + self.vector * other.scalar + other.vector * self.scalar, self.scalar * other.scalar - self.vector.dot(other.vector))
    
    @staticmethod
    def from_axis_angle(axis, angle):
        sin = math.sin(angle / 360.0 * math.pi)
        vec = axis/ axis.length()
        return Quaternion(vec * sin, math.sqrt(1.0 - sin * sin))

class Transform:
    def __init__(self, translation, rotation, scale):
        self.vec0 = rotation * Vector(scale.x, 0.0, 0.0)
        self.vec1 = rotation * Vector(0.0, scale.y, 0.0)
        self.vec2 = rotation * Vector(0.0, 0.0, scale.z)
        self.vec3 = rotation * translation

class Tetrahedron:
    def __init__(self):
        self.vertices = []
        self.attempts = []
    
    def add_vertex(self, vertex):
        # Reject if a line segment between this and another vector in the simplex crosses the origin.
        if [x for x in filter(lambda x: x.cross(vertex) == Vector.ORIGIN, self.vertices)]:
            print("Failed to add vertex %s: Degenerate vertex already in simplex" % (vertex))
            return False
        # Reject if the line segment between this vertex and the last inseted vertex doesn't pass the origin.
        # Maybe perform this check against all the other segments?
        if self.vertices and vertex.dot(vertex - self.vertices[-1]) < 0.0:
            print("Failed to add vertex %s: Vertex doesn't pass origin" % (vertex))
            return False
        # Abort if we try to add more than 4 vertices by mistake.
        if len(self.vertices) >= 4:
            raise Exception("Too many vertices for simplex")
        self.vertices.append(vertex)
        # Clear all the vertices if the current simplex doesn't contain the origin.
        if len(self.vertices) == 4 and self.vertices in self.attempts:
            print("Failed to add vertex %s: Repeated simplex" % (vertex))
            self.vertices.clear()
            return False
        print("Successfully added vertex %s" % (vertex))
        return True
    
    def contains_origin(self):
        if len(self.vertices) < 4:
            return False
        # Loop over all the face index permutations, with the 4th index indicating each face's opposite vertex.
        for indices in ((0, 1, 2, 3), (0, 1, 3, 2), (0, 2, 3, 1), (1, 2, 3, 0)):
            # Find the perpendicular vector to the face's plane, which can be pointing either inside or outside.
            perp = (self.vertices[indices[1]] - self.vertices[indices[0]]).cross(self.vertices[indices[2]] - self.vertices[indices[0]])
            # Make sure that the vector perpendicular to the face points outwards using the opposite vertex as guide.
            if perp.dot(self.vertices[indices[0]] - self.vertices[indices[3]]) < 0.0:
                perp = -perp
            # Fail if the origin is in front of the face.
            if perp.dot(self.vertices[indices[0]]) < 0.0:
                self.attempts.append(self.vertices)
                self.vertices = []
                print("Origin  not in simplex")
                return False
        print("Origin in simplex")
        return True
    
    def suggest_direction(self):
        match len(self.vertices):
            case 1:
                # Return the direction to the origin.
                return -self.vertices[0]
            case 2:
                # Return a vector perpendicular to the line segment in the general direction of the origin.
                return (self.vertices[1] - self.vertices[0]).cross(-self.vertices[0]).cross(self.vertices[1] - self.vertices[0])
            case 3:
                # Return the vector perpendicular to the face in the general direction of the origin.
                perp = (self.vertices[1] - self.vertices[0]).cross(self.vertices[2] - self.vertices[0])
                return perp if perp.dot(self.vertices[0]) < 0.0 else -perp

class Box:
    def __init__(self, transform):
        self.position = transform.vec3
        self.vertices = (
            transform.vec3 - transform.vec0 - transform.vec1 - transform.vec2,
            transform.vec3 + transform.vec0 - transform.vec1 - transform.vec2,
            transform.vec3 - transform.vec0 + transform.vec1 - transform.vec2,
            transform.vec3 + transform.vec0 + transform.vec1 - transform.vec2,
            transform.vec3 - transform.vec0 - transform.vec1 + transform.vec2,
            transform.vec3 + transform.vec0 - transform.vec1 + transform.vec2,
            transform.vec3 - transform.vec0 + transform.vec1 + transform.vec2,
            transform.vec3 + transform.vec0 + transform.vec1 + transform.vec2
        )
    
    def find_support_point(self, direction):
        if direction.square_length() == 0.0:
            raise Exception("Direction is null vector")
        # Find the farthest point in a specific direction.
        best = None
        max = -math.inf
        for vertex in self.vertices:
            dot = vertex.dot(direction)
            if dot > max:
                best = vertex
                max = dot
        return best

def shape_intersects_shape(shape0, shape1):
    # Centroids overlapping definitely means collision.
    if shape1.position == shape0.position:
        print("Centroids overlap")
        return True
    tet = Tetrahedron()
    # Generate the first direction vector pointing at the other solid's centroid.
    dir = shape1.position - shape0.position
    point0 = shape0.find_support_point(-dir)
    point1 = shape1.find_support_point(dir)
    diff = point1 - point0
    tet.add_vertex(diff)
    while True:
        dir = tet.suggest_direction()
        # If no direction is suggested, indicating no simplex vertices, aim at the previously defined difference.
        if not dir:
            dir = diff
        point0 = shape0.find_support_point(-dir)
        point1 = shape1.find_support_point(dir)
        diff = point1 - point0
        # Succeed if the Minkowski difference returns the origin as that means that the solids are touching.
        if diff == Vector.ORIGIN:
            print("Degenerate case (solids touching)")
            return True
        # If a vertex fails to be added, that's the halting condition.
        if not tet.add_vertex(diff):
            return False
        # If the simplex contains the origin, then the solids are overlapping.
        if tet.contains_origin():
            return True

def test(name, actual, expected):
    print("%s: %s" % (name, "Passed" if actual == expected else "Failed"))

epsilon = 1e-3

transform = Transform(Vector(0.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0), Vector(1.0, 1.0, 1.0))
box0 = Box(transform)
test("Same box", shape_intersects_shape(box0, box0), True)
transform = Transform(Vector(0.5, 1.5, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0), Vector(1.0, 1.0, 1.0))
box1 = Box(transform)
test("Intersecting boxes", shape_intersects_shape(box0, box1), True)
transform = Transform(Vector(0.0, 3.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0), Vector(1.0, 1.0, 1.0))
box2 = Box(transform)
test("Separate boxes", shape_intersects_shape(box0, box2), False)
transform = Transform(Vector(0.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 0.0), Vector(1.0, 1.0, 1.0))
box3 = Box(transform)
test("Intersecting boxes forming a star", shape_intersects_shape(box0, box3), True)
transform = Transform(Vector(2.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0), Vector(1.0, 1.0, 1.0))
box4 = Box(transform)
test("Boxes with faces touching", shape_intersects_shape(box0, box4), True)
transform = Transform(Vector(0.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0), Vector(1.0, 4.0, 1.0))
box5 = Box(transform)
transform = Transform(Vector(0.0, 2.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0), Vector(3.0, 1.0, 1.0))
box6 = Box(transform)
test("Tall and wide boxes forming a T", shape_intersects_shape(box5, box6), True)
transform = Transform(Vector(0.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 30.0), Vector(1.0, 4.0, 1.0))
box7 = Box(transform)
transform = Transform(Vector(0.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), -30.0), Vector(1.0, 4.0, 1.0))
box8 = Box(transform)
test("Tall boxes forming an X", shape_intersects_shape(box7, box8), True)
transform = Transform(Vector(0.0, 0.0, 3.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), -30.0), Vector(1.0, 4.0, 1.0))
box9 = Box(transform)
test("Skew tall boxes", shape_intersects_shape(box7, box9), False)
transform = Transform(Vector(-5.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0), Vector(1.0, 4.0, 1.0))
box10 = Box(transform)
transform = Transform(Vector(5.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), -45.0), Vector(1.0, 4.0, 1.0))
box11 = Box(transform)
test("Boxes forming a V with only edges touching", shape_intersects_shape(box10, box11), True)
transform = Transform(Vector(0.0, 0.0, 0.0), Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0), Vector(4.0, 4.0, 4.0))
box12 = Box(transform)
transform = Transform(Vector(0.5, 1.0, 0.0), Quaternion.from_axis_angle(Vector(1.5, 1.5, 1.0), 30.0), Vector(1.0, 1.0, 1.0))
box13 = Box(transform)
test("Container and contained boxes", shape_intersects_shape(box12, box13), True)
Centroids overlap
Same box: Passed
Successfully added vertex [x: -0.71, y: 4.24, z: 0.00]
Successfully added vertex [x: -0.71, y: -1.41, z: 0.00]
Successfully added vertex [x: 2.12, y: 1.41, z: 0.00]
Successfully added vertex [x: -0.71, y: 1.41, z: -2.00]
Origin in simplex
Intersecting boxes: Passed
Successfully added vertex [x: -3.54, y: 3.54, z: 0.00]
Failed to add vertex [x: -0.71, y: 0.71, z: 0.00]: Degenerate vertex already in simplex
Separate boxes: Passed
Centroids overlap
Intersecting boxes forming a star: Passed
Successfully added vertex [x: 2.83, y: 2.83, z: 0.00]
Degenerate case (solids touching)
Boxes with faces touching: Passed
Successfully added vertex [x: -6.36, y: 3.54, z: 0.00]
Successfully added vertex [x: 4.95, y: 0.71, z: 0.00]
Successfully added vertex [x: -0.71, y: -4.95, z: 0.00]
Successfully added vertex [x: -4.95, y: 2.12, z: 2.00]
Origin in simplex
Tall and wide boxes forming a T: Passed
Centroids overlap
Tall boxes forming an X: Passed
Successfully added vertex [x: -4.00, y: 1.00, z: 5.00]
Successfully added vertex [x: 5.73, y: 0.00, z: 1.00]
Successfully added vertex [x: -5.73, y: 0.00, z: 1.00]
Successfully added vertex [x: 0.00, y: 7.93, z: 1.00]
Origin  not in simplex
Successfully added vertex [x: 0.00, y: 7.93, z: 5.00]
Successfully added vertex [x: 0.00, y: -7.93, z: 1.00]
Successfully added vertex [x: 0.00, y: 7.93, z: 1.00]
Successfully added vertex [x: -5.73, y: 0.00, z: 3.00]
Origin  not in simplex
Successfully added vertex [x: -5.73, y: 0.00, z: 5.00]
Successfully added vertex [x: 5.73, y: 0.00, z: 1.00]
Successfully added vertex [x: -5.73, y: 0.00, z: 1.00]
Successfully added vertex [x: 0.00, y: -7.93, z: 3.00]
Origin  not in simplex
Successfully added vertex [x: 0.00, y: -7.93, z: 5.00]
Successfully added vertex [x: 0.00, y: 7.93, z: 1.00]
Successfully added vertex [x: 0.00, y: -7.93, z: 1.00]
Successfully added vertex [x: 5.73, y: 0.00, z: 3.00]
Origin  not in simplex
Successfully added vertex [x: 5.73, y: 0.00, z: 5.00]
Successfully added vertex [x: -5.73, y: 0.00, z: 1.00]
Successfully added vertex [x: 5.73, y: 0.00, z: 1.00]
Successfully added vertex [x: 0.00, y: 7.93, z: 3.00]
Origin  not in simplex
Successfully added vertex [x: 0.00, y: 7.93, z: 5.00]
Successfully added vertex [x: 0.00, y: -7.93, z: 1.00]
Successfully added vertex [x: 0.00, y: 7.93, z: 1.00]
Failed to add vertex [x: -5.73, y: 0.00, z: 3.00]: Repeated simplex
Skew tall boxes: Passed
Successfully added vertex [x: 14.14, y: 0.00, z: 0.00]
Degenerate case (solids touching)
Boxes forming a V with only edges touching: Passed
Successfully added vertex [x: 0.71, y: 8.18, z: 3.40]
Successfully added vertex [x: -0.82, y: -5.51, z: -4.75]
Successfully added vertex [x: -0.10, y: -6.07, z: 5.03]
Successfully added vertex [x: 7.39, y: 0.12, z: -3.53]
Origin in simplex
Container and contained boxes: Passed
Espero que isso ajude. Como eu disse, eu amo esse assunto e aprendi muito desde minha primeira resposta a este tópico.
E-mailPM
Denunciar Citação
Afirmativo
#17
roger_m
2024-03-29 11:51:14
Estranho da galáxia
On-line
Registrado: 2022-12-12
Postagens: 44
Karma do usuário: 5
@16
Olá, desculpe pela demora.
Você me forneceu muito material de estudo, e sou muito grato por isso.
Não consegui olhar como gostaria, mas pretendo fazer isso nas próximas semanas, quando as coisas se acalmarem um pouco por aqui.
Voltarei com atualizações sobre o mesmo tópico, e muito obrigado!
E-mail
Denunciar Excluir Editar Citar
#18
Frio
2024-04-05 22:01:07
Tons de novato
Desligado
Registrado: 2021-11-13
Postagens: 19
Karma do usuário: 2
Eu não consideraria meu trabalho feito aqui sem estender o algoritmo de detecção de colisão para também produzir o vetor de penetração mínimo necessário para empurrar um dos objetos para longe o suficiente para que eles parem de colidir, então pesquisei um pouco mais e implementei o Algoritmo de Politopo em Expansão, que se integra bem com o algoritmo Gilbert-Johnson-Keerthi ao fazer uso do simplex que ele gera como o politopo inicial. Também fornecerei uma descrição de ambos os algoritmos, pois embora ambos sejam bem simples quando os entendemos, a EPA levou um bom tempo para eu entender.
Para GJK e EPA, precisamos de uma função de suporte que calcule o produto escalar entre todos os vértices em uma forma e um dado vetor de direção para retornar o vértice que está mais distante naquela direção, que é o vetor com o maior produto escalar. Esta função é então usada para calcular pontos do casco da nuvem de diferença de Minkowski, que é a diferença entre todas as combinações de vetores de ambos os objetos. Um fato interessante sobre a nuvem de diferença de Minkowski é que sua forma não muda quando a distância entre os dois objetos muda, e o vetor de distância mínima ou vetor de penetração mínima é o vetor da projeção da origem na face mais próxima de seu casco à origem. Este fato também pode ser usado para calcular o plano de separação entre os dois objetos para provar o Teorema do Eixo de Separação.
GJK requer tentar construir um simplex (um tetraedro neste caso) ao redor da origem usando os vértices externos da nuvem de diferença de Minkowski. Se você conseguir desenhar tal simplex, então os objetos estão colidindo. Ele começa com um vetor apontando em qualquer direção aleatoriamente, embora algumas escolhas, como a diferença entre os centroides de ambos os sólidos, devam, em teoria, resultar em menos cálculos, então é isso que eu escolho como o vetor inicial, a menos que os centroides sejam os mesmos, caso em que eu apenas escolho o vetor unitário no eixo X. Uma vez que temos uma direção, usamos a função de suporte para encontrar o vetor mais extremo em um dos objetos e então encontramos o vetor mais extremo na direção oposta no outro objeto. Subtrair um dos vetores do outro produz um dos vetores no casco da nuvem de Minkowski, que também é o primeiro ponto em nosso simplex. O segundo ponto é obtido seguindo os passos anteriores na direção oposta do nosso primeiro ponto em direção à origem. O terceiro ponto é obtido calculando um vetor perpendicular da linha formada pelos dois primeiros vetores que encontramos na direção geral da origem, e finalmente o quarto ponto é obtido usando a função de suporte como mencionado anteriormente com a direção perpendicular ao triângulo formado pelos três primeiros vetores na direção geral da origem. Se em qualquer uma dessas etapas uma das linhas não passar pela origem, então essa é uma condição de término, pois é garantido que os objetos não estão colidindo. Se qualquer um dos vértices for a origem, então temos um caso degenerado, o que significa que os sólidos estão mal se tocando. Se a origem for parte de qualquer uma das facetas ou arestas do simplex, então a próxima direção é um vetor aleatório perpendicular à aresta ou faceta que contém a origem. Se o tetraedro formado por esses 4 pontos contiver a origem, então essa é uma condição de término para GJK, pois há uma colisão; caso contrário, tente formar um novo tetraedro começando do último vértice e repita todo o processo até que você possa formar um simplex de tetraedro com a origem dentro, indicando uma colisão, ou um simplex tentado anteriormente seja criado novamente, caso em que não há colisão. Não termine GJK antes, mesmo se você encontrar a origem em uma aresta ou faceta do simplex de tetraedro sem terminar de encontrar os quatro pontos do simplex, pois o EPA na próxima etapa começa a partir de um simplex totalmente construído.
O EPA começa com um simplex totalmente construído em torno da origem, como mencionado no parágrafo anterior, e aqui o objetivo é gerar um politopo convexo cada vez maior (um poliedro neste caso) até que a faceta mais próxima do casco de diferença de Minkowski seja encontrada. Para fazer isso, você procura a faceta do poliedro atual que está mais próxima da origem, usa a função de suporte para encontrar os vértices mais extremos de ambos os objetos, assim como em GJK, mas desta vez usando a normal da faceta como direção, e adiciona vértices ao poliedro, certificando-se de mantê-lo convexo até encontrar um vértice que já faça parte dele. Uma vez que o algoritmo termina, o vetor de penetração mínima é a diferença entre a projeção da origem na faceta mais próxima do poliedro gerado e a origem. Este algoritmo parece mais fácil do que GJK porque tem muito menos regras, mas levei algum tempo para descobrir como manter o poliedro convexo o tempo todo com todas as normais apontando para fora.
Código e saída a seguir:
import math

class Vector:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    
    def __repr__(self):
        return "[x: %.03f, y: %.03f, z: %.03f]" % (self.x, self.y, self.z)
    
    def __eq__(self, other):
        return round(self.x, 3) == round(other.x, 3) and round(self.y, 3) == round(other.y, 3) and round(self.z, 3) == round(other.z, 3)
    
    def __hash__(self):
        return hash((round(self.x, 3), round(self.y, 3), round(self.z, 3)))
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)
    
    def __mul__(self, other):
        if isinstance(other, float):
            return Vector(self.x * other, self.y * other, self.z * other)
        return Vector(self.x * other.x, self.y * other.y, self.z * other.z)
    
    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y, self.z - other.z)
    
    def __truediv__(self, other):
        if isinstance(other, float):
            return Vector(self.x / other, self.y / other, self.z / other)
        return Vector(self.x / other.x, self.y / other.y, self.z / other.z)
    
    def __neg__(self):
        return Vector(-self.x, -self.y, -self.z)
    
    def dot(self, other):
        return round(self.x * other.x + self.y * other.y + self.z * other.z, 3)
    
    def cross(self, other):
        return Vector(self.y * other.z - self.z * other.y, self.z * other.x - self.x * other.z, self.x * other.y - self.y * other.x)
    
    def square_length(self):
        return self.dot(self)
    
    def length(self):
        return round(math.sqrt(self.square_length()), 3)
    
    def normalize(self):
        return self/ self.length()

Vector.ORIGIN = Vector(0.0, 0.0, 0.0)

class Quaternion:
    def __init__(self, vector, scalar):
        self.vector = vector
        self.scalar = scalar
    
    def __mul__(self, other):
        if isinstance(other, Vector):
            conj = Quaternion(-self.vector, self.scalar)
            vec = Quaternion(other, 0.0)
            quat = self * vec * conj
            return quat.vector
        return Quaternion(self.vector.cross(other.vector) + self.vector * other.scalar + other.vector * self.scalar, self.scalar * other.scalar - self.vector.dot(other.vector))
    
    @staticmethod
    def from_axis_angle(axis, angle):
        sin = math.sin(angle / 360.0 * math.pi)
        vec = axis/ axis.length()
        return Quaternion(vec * sin, math.sqrt(1.0 - sin * sin))

class Transform:
    def __init__(self, vec0, vec1, vec2, vec3):
        self.vec0 = vec0
        self.vec1 = vec1
        self.vec2 = vec2
        self.vec3 = vec3
    
    def __add__(self, translation):
        return Transform(self.vec0, self.vec1, self.vec2, self.vec3 + translation)
    
    @staticmethod
    def from_components(translation, rotation, scale):
        return Transform(rotation * Vector(scale.x, 0.0, 0.0), rotation * Vector(0.0, scale.y, 0.0), rotation * Vector(0.0, 0.0, scale.z), rotation * translation)

class Simplex:
    def __init__(self):
        self.vertices = []
        self.attempts = []
        self.finished = False
    
    def add_vertex(self, vertex):
        if self.finished:
            return True
        # Reject if the last line segment formed with this vertex do not pass the origin.
        if self.vertices and vertex.dot(vertex - self.vertices[-1]) < 0.0:
            return False
        # Reject if the vertex is the origin.
        if vertex == Vector.ORIGIN:
            self.finished = True
            return False
        match len(self.vertices):
            case 2:
                # Reject if the line formed by the other two vertices contains this vertex.
                if vertex.cross(self.vertices[1] - self.vertices[0]) == Vector.ORIGIN:
                    return False
            case 3:
                # Reject if the vertex is coplanar the plane formed by the other three vertices.
                perp = (self.vertices[1] - self.vertices[0]).cross(self.vertices[2] - self.vertices[0])
                if perp.dot(vertex - self.vertices[0]) == 0.0:
                    return False
            case 4:
                self.vertices.clear()
        # Fail if the vertex is duplicate.
        if vertex in self.vertices:
            return False
        self.vertices.append(vertex)
        # Fail if this simplex has already been tried.
        if len(self.vertices) == 4:
            for attempt in self.attempts:
                for vertex in self.vertices:
                    if vertex not in attempt:
                        break
                else:
                    return False
            self.attempts.append(self.vertices.copy())
        return True
    
    def contains_origin(self):
        if self.finished:
            return len(self.vertices) == 4
        if len(self.vertices) == 4:
            # Fail if the origin is in front of any of the faces.
            for face in ((0, 1, 2, 3), (0, 1, 3, 2), (0, 2, 3, 1), (1, 2, 3, 0)):
                # Find the vector perpendicular to the face.
                perp = (self.vertices[face[1]] - self.vertices[face[0]]).cross(self.vertices[face[2]] - self.vertices[face[0]])
                # Make sure that the vector points outwards.
                perp = perp * perp.dot(self.vertices[face[0]] - self.vertices[face[3]])
                # Check whether the origin is in front of the face.
                if perp.dot(self.vertices[face[0]]) < 0.0:
                    break
            else:
                self.finished = True
        else:
            return False
        return self.finished
    
    def suggest_direction(self):
        if self.finished:
            return
        match len(self.vertices):
            case 1:
                # Return the direction to the origin.
                return -self.vertices[0]
            case 2:
                # If the segment crosses the origin, suggest a random perpendicular vector.
                if self.vertices[0].cross(self.vertices[1]) == Vector.ORIGIN:
                    perpx = Vector(1.0, 0.0, 0.0).cross(self.vertices[1])
                    return perpx if perpx != Vector.ORIGIN else Vector(0.0, 1.0, 0.0).cross(self.vertices[1])
                # Return a vector perpendicular to the line segment in the general direction of the origin.
                return (self.vertices[1] - self.vertices[0]).cross(-self.vertices[0]).cross(self.vertices[1] - self.vertices[0])
            case 3:
                # If the the origin is on the same plane as the triangle, return a random vector perpendicular to it.
                perp = (self.vertices[1] - self.vertices[0]).cross(self.vertices[2] - self.vertices[0])
                proj = perp.dot(self.vertices[0])
                if proj == 0.0:
                    return perp
                # Return the vector perpendicular to the triangle in the general direction of the origin.
                return (perp * -proj)

class Triangle:
    def __init__(self, vertex0, vertex1, vertex2):
        self.vertices = (vertex0, vertex1, vertex2)
        perp = (vertex1 - vertex0).cross(vertex2 - vertex0)
        self.normal = perp.normalize()
        self.distance = self.normal.dot(vertex0)
    
    def faces_point(self, point):
        return self.normal.dot(point - self.vertices[0]) > 0.0
    
    @staticmethod
    def from_simplex(simplex):
        tris = []
        for facet in ((0, 1, 2, 3), (1, 0, 3, 2), (2, 3, 0, 1), (3, 2, 1, 0)):
            perp = (simplex.vertices[facet[1]] - simplex.vertices[facet[0]]).cross(simplex.vertices[facet[2]] - simplex.vertices[facet[0]])
            if perp.dot(simplex.vertices[facet[0]] - simplex.vertices[facet[3]]) > 0.0:
                tris.append(Triangle(simplex.vertices[facet[0]], simplex.vertices[facet[1]], simplex.vertices[facet[2]]))
            else:
                tris.append(Triangle(simplex.vertices[facet[2]], simplex.vertices[facet[1]], simplex.vertices[facet[0]]))
        return tris

class Polyhedron:
    def __init__(self, simplex):
        # If one of the vertices of the simplex is the origin, then this is a degenerate case.
        self.finished = Vector.ORIGIN in simplex.vertices
        if self.finished:
            return
        self.triangles = Triangle.from_simplex(simplex)
        # Keep track of the number of references to each vertex of the polyhedron.
        self.vertex_count = {
            simplex.vertices[0]: 3,
            simplex.vertices[1]: 3,
            simplex.vertices[2]: 3,
            simplex.vertices[3]: 3
        }
    
    def add_triangle(self, triangle):
        self.triangles.append(triangle)
        for vert in triangle.vertices:
            ct = self.vertex_count.setdefault(vert, 0)
            self.vertex_count[vert] = ct + 1
    
    def remove_triangle(self, triangle):
        self.triangles.remove(triangle)
        for vert in triangle.vertices:
            ct = self.vertex_count[vert]
            self.vertex_count[vert] = ct - 1
    
    def add_vertex(self, vertex):
        if self.finished:
            return False
        # Terminate if this vertex has already been added.
        if vertex in self.vertex_count.keys():
            self.finished = True
            return False
        # Mark the triangles whose front faces can see the new vertex for deletion to prevent concavities.
        oldtris = []
        for tri in self.triangles:
            if tri.faces_point(vertex):
                oldtris.append(tri)
        # If the new vertex is part of the polyhedron then we have already found the face closest to the origin.
        if not oldtris:
            self.finished = True
            return False
        # Extract unique vectors from the triangles marked for deletion and delete them.
        rem = []
        for tri in oldtris:
            self.remove_triangle(tri)
            for vert in tri.vertices:
                if not vert in rem:
                    rem.append(vert)
        # Filter out the deleted vertices that don't have any other references.
        dangs = [x for x in filter(lambda x: self.vertex_count[x] > 0, rem)]
        # Compute an average vector between the new vertex and the dangling vertices.
        dirs = [x for x in map(lambda x: (x - vertex).normalize(), dangs)]
        avgdir = sum(dirs, Vector.ORIGIN)
        # Compute the horizontal, vertical, and depth axis.
        dp = -avgdir.normalize()
        vt = (avgdir).cross(dirs[0]).normalize()
        hz = avgdir.cross(vt).normalize()
        # Sort the dangling vertices by angle.
        dangdirs = [x for x in map(lambda x: (dangs[x], (dirs[x] - dp * dirs[x].dot(dp)).normalize()), range(len(dangs)))]
        dangdirs = [x for x in sorted(dangdirs, key = lambda x: -math.copysign(x[1].dot(hz) + 1.0, x[1].dot(vt)))]
        # Create the new triangles using the sorted angles to ensure that their normals point outwards.
        for idx in range(len(dangdirs)):
            tri = Triangle(dangdirs[idx][0], dangdirs[(idx + 1) % len(dangdirs)][0], vertex)
            self.add_triangle(tri)
        return True
    
    def suggest_direction(self):
        dir = None
        mindist = math.inf
        for tri in self.triangles:
            dist = tri.distance
            if dist < mindist:
                dir = tri.normal
                mindist = dist
        return dir
    
    def compute_origin_translation(self):
        if not self.finished:
            return
        mindist = math.inf
        norm = None
        for tri in self.triangles:
            dist = tri.distance
            if dist < mindist:
                mindist = dist
                norm = tri.normal
        if norm:
            pen = norm * -mindist
            if pen != Vector.ORIGIN:
                return pen

class Box:
    def __init__(self, transform):
        self.position = transform.vec3
        self.vertices = (
            self.position - transform.vec0 - transform.vec1 - transform.vec2,
            self.position + transform.vec0 - transform.vec1 - transform.vec2,
            self.position - transform.vec0 + transform.vec1 - transform.vec2,
            self.position + transform.vec0 + transform.vec1 - transform.vec2,
            self.position - transform.vec0 - transform.vec1 + transform.vec2,
            self.position + transform.vec0 - transform.vec1 + transform.vec2,
            self.position - transform.vec0 + transform.vec1 + transform.vec2,
            self.position + transform.vec0 + transform.vec1 + transform.vec2
        )
    
    def find_support_point(self, direction):
        if direction == Vector.ORIGIN:
            raise Exception("Direction is null vector")
        # Find the farthest point in a specific direction.
        best = None
        max = -math.inf
        for vertex in self.vertices:
            dot = vertex.dot(direction)
            if dot > max:
                best = vertex
                max = dot
        return best

def shape_intersects_shape(shape0, shape1):
    smpx = Simplex()
    # Generate the first direction vector.
    dir = shape1.position - shape0.position
    if dir == Vector.ORIGIN:
        dir = Vector(0.0, 0.0, 1.0)
    # Check whether the shapes are intersecting using GJK.
    while True:
        point0 = shape0.find_support_point(-dir)
        point1 = shape1.find_support_point(dir)
        diff = point1 - point0
        # If a vertex fails to be added, there's no way to progress further.
        if not smpx.add_vertex(diff):
            return
        # If the simplex contains the origin, then the solids are overlapping.
        if smpx.contains_origin():
            break
        dir = smpx.suggest_direction()
        # If no direction is suggested, indicating no simplex vertices, aim at the previously defined difference.
        if not dir:
            dir = diff
    # Compute the minimum penetration vector using EPA.
    pldr = Polyhedron(smpx)
    while True:
        dir = pldr.suggest_direction()
        point0 = shape0.find_support_point(-dir)
        point1 = shape1.find_support_point(dir)
        diff = point1 - point0
        if not pldr.add_vertex(diff):
            return pldr.compute_origin_translation()

def test(name, shape0, shape1):
    push = shape_intersects_shape(shape0, shape1)
    res = None
    if push:
        shape2 = Box(transform + push)
        res = shape_intersects_shape(shape0, shape2) if push else None
    print("%s: %s (pushed: %s)" % (name, "Passed" if not res else "Failed", push))

translation = Vector(0.0, 0.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(1.0, 1.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box0 = Box(transform)
test("Same box", box0, box0)

translation = Vector(0.5, 1.5, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(1.0, 1.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box1 = Box(transform)
test("Intersecting boxes", box0, box1)

translation = Vector(0.0, 3.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(1.0, 1.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box2 = Box(transform)
test("Separate boxes", box0, box2)

translation = Vector(0.0, 0.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(1.0, 0.0, 0.0), 45) * Quaternion.from_axis_angle(Vector(1.0, 0.0, 0.0), 45)
scale = Vector(1.0, 1.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box3 = Box(transform)
test("Intersecting boxes forming a star", box0, box3)

translation = Vector(0.0, 2.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(1.0, 1.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box4 = Box(transform)
test("Boxes with faces touching", box0, box4)

translation = Vector(0.0, 0.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(1.0, 4.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box5 = Box(transform)
translation = Vector(0.0, 2.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(3.0, 1.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box6 = Box(transform)
test("Tall and wide boxes forming a cross", box5, box6)

translation = Vector(0.0, 0.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 30.0)
scale = Vector(1.0, 4.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box7 = Box(transform)
translation = Vector(0.0, 0.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), -30.0)
scale = Vector(1.0, 4.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box8 = Box(transform)
test("Tall boxes forming an X", box7, box8)

translation = Vector(0.0, 0.0, 3.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), -30.0)
scale = Vector(1.0, 4.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box9 = Box(transform)
test("Skew tall boxes", box7, box9)

translation = Vector(-5.0, 0.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(1.0, 4.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box10 = Box(transform)
translation = Vector(5.0, 0.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), -45.0)
scale = Vector(1.0, 4.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box11 = Box(transform)
test("Boxes forming a V with only edges touching", box10, box11)

translation = Vector(0.0, 0.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(4.0, 4.0, 4.0)
transform = Transform.from_components(translation, rotation, scale)
box12 = Box(transform)
translation = Vector(0.5, 1.0, 0.0)
rotation = Quaternion.from_axis_angle(Vector(0.0, 0.0, 1.0), 45.0)
scale = Vector(1.0, 1.0, 1.0)
transform = Transform.from_components(translation, rotation, scale)
box13 = Box(transform)
test("Container and contained boxes", box12, box13)
Same box: Passed (pushed: [x: -1.414, y: -1.414, z: -0.000])
Intersecting boxes: Passed (pushed: [x: -0.354, y: 0.354, z: -0.000])
Separate boxes: Passed (pushed: None)
Intersecting boxes forming a star: Passed (pushed: [x: -0.000, y: -0.001, z: -2.001])
Boxes with faces touching: Passed (pushed: None)
Tall and wide boxes forming a cross: Passed (pushed: [x: -0.000, y: -0.000, z: 2.000])
Tall boxes forming an X: Passed (pushed: [x: 0.000, y: -0.000, z: 2.000])
Skew tall boxes: Passed (pushed: None)
Boxes forming a V with only edges touching: Passed (pushed: None)
Container and contained boxes: Passed (pushed: [x: -2.828, y: 2.828, z: -0.000])
PS: Por algum motivo, o VoiceOver no MacOS não está lendo o parágrafo inteiro do GJK, então, se você estiver em um Mac, recomendo usar a navegação por cursor para ler linha por linha.
E-mailPM
Denunciar Citação
Afirmativo
Postagens: 18
Páginas
1
Postar resposta
Fórum AudioGames.net  ?  Sala de desenvolvedores  ?  Ajuda com caixas orientadas
Resposta rápida para este tópico
Você pode usar: Imagens BBCode  SmiliesAjuda com: Imagens Ajuda com: Smilies
Escrever mensagem
 
Enviar visualização
Sala de desenvolvedores
Desenvolvido por PanBB
Atualmente instaladas 5 extensões oficiais . Copyright © 2003–2009 PunBB .
Gerado em 0,061 segundos (52% PHP - 48% DB) com 11 consultas
 
