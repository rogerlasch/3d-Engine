


#ifndef GPP_MATH_H
#define GPP_MATH_H

#include<vector>
#include"vector3d.h"
#include"matrix3x3.h"
#include"quaternion.h"
#include"ray.h"
#include"MathCollision.h"


namespace gpp{

#define GPP_PI 3.1415926
#define GPP_EPSILON 0.0000001f
#define GPP_DISTANCE_TOLERANCE 0.01f

float degrees_to_radians(float f);
float radians_to_degrees(float r);
float gpp_clamp(float n, float min, float max);
float ClosestPtSegmentSegment(const vector3d& p1, const vector3d& q1, const vector3d& p2, const vector3d& q2,                                              float &s, float &t, vector3d& c1, vector3d& c2);
float ClosestPtPointSegment(const vector3d& c, const vector3d& a, const vector3d& b, float &t, vector3d &d);
                 float SqDistPointSegment(const vector3d& a, const vector3d& b, const vector3d& c);
void calculateBoundingBox(const std::vector<vector3d>& points, vector3d& min, vector3d& max);
bool point_in_box(const vector3d& p, const vector3d& min, const vector3d& max);
}
#endif



#ifndef MATHCOLLISION_H
#define MATHCOLLISION_H

namespace gpp{

bool computeSphereSphereCollision(const vector3d& c1, float r1, const vector3d& c2, float r2, vector3d& point, vector3d& normal, float& depth);
bool computeSphereBoxCollision(const vector3d& lp, const vector3d& closestPoint, const vector3d& center, float radius, const vector3d& min, const vector3d& max, vector3d& point, vector3d& normal, float& depth);
bool computeBoxSphereCollision(const vector3d& lp, const vector3d& closestPoint, const vector3d& min, const vector3d& max, const vector3d& center, float radius, vector3d& point, vector3d& normal, float& depth);
}
#endif

/**
*Classe para uma matriz 3x3 útil em algumas situações.
*Esta classe foi retirada do livro physics for game developers.
*Alguns metodos foram adicionados a ela.
**/
#ifndef MATRIX3X3_H
#define MATRIX3X3_H

#include<iostream>

namespace gpp
{
      class matrix3x3 {
      public:
             // elements eij: i -> row, j -> column
             float e11, e12, e13, e21, e22, e23, e31, e32, e33;
matrix3x3(void);
matrix3x3(float r1c1, float r1c2, float r1c3,                 float r2c1, float r2c2, float r2c3,                float r3c1, float r3c2, float r3c3 );
matrix3x3(const matrix3x3& mt);
matrix3x3& operator=(const matrix3x3& mt);
             matrix3x3& operator+=(const matrix3x3& m);
             matrix3x3& operator-=(const matrix3x3& m);
             matrix3x3& operator*=(float s);
             matrix3x3& operator/=(float s);
void clear();
float      det(void);
matrix3x3  Transpose(void);
matrix3x3  Inverse(void);
void Identity();
void setDiagonal(const vector3d& v);
vector3d getDiagonal()const;
std::string toString()const;
      };

std::ostream& operator<<(std::ostream& os, const matrix3x3& mt);
       matrix3x3 operator+(const matrix3x3& m1, const matrix3x3& m2);
       matrix3x3 operator-(const matrix3x3& m1, const matrix3x3& m2);
       matrix3x3 operator/(float s, const matrix3x3& m);
       matrix3x3 operator/(const matrix3x3& m, float s);
       matrix3x3 operator*(const matrix3x3& m1, const matrix3x3& m2);
       matrix3x3 operator*(const matrix3x3& m, float s);
       matrix3x3 operator*(float s, const matrix3x3& m);
       vector3d operator*(const matrix3x3& m, const vector3d& u);
 vector3d operator*(const vector3d& u, const matrix3x3& m);
}
#endif


/**
*Classe de quatérnion para a simulação.
*Esta classe também foi retirada do livro Physics for game developers.
*Vários métodos adicionais foram adicionados.
*Esta classe serve para armazenar a orientação de um corpo no espaço.
**/

#ifndef QUATERNION_H
#define QUATERNION_H

namespace gpp
{

/*
* Classe de quatérnions fortemente baseada na classe quaternion do livro Physics for Game Developers.
**/
class quaternion
{
public:
float x;
float y;
float z;
float w;
quaternion(float x=0.0f, float y=0.0f, float z=0.0f, float w=0.0f);
quaternion(float w, const vector3d& v);
quaternion(const quaternion& q);
quaternion& operator=(const quaternion& q);
bool operator==(const quaternion& q);
quaternion& operator+=(float s);
quaternion& operator-=(float s);
quaternion& operator*=(float s);
quaternion& operator/=(float s);
quaternion& operator+=(const quaternion& q);
quaternion& operator-=(const quaternion& q);
quaternion operator~()const;
void setX(float x);
float getX()const;
void setY(float y);
float getY()const;
void setZ(float z);
float getZ()const;
void setW(float w);
float getW()const;
//Calcula o comprimento do quatérnion...
float length()const;
//Método de conjugar o quatérnion...
quaternion conjugate()const;
//Normaliza o quaternion...
quaternion& normalize();
quaternion& setIdentity();
//Retorna o ângulo que o quatérnion está representando...
float getAngle()const;
vector3d getAxis()const;
std::string toString()const;
};

//Sobrecarga dos operadores do quatérnion...

std::ostream& operator<<(std::ostream& os, const quaternion& q);
quaternion operator+(const quaternion& q, float s);
quaternion operator+(float s, const quaternion& q);
quaternion operator-(const quaternion& q, float s);
quaternion operator-(float s, const quaternion& q);
quaternion operator*(const quaternion& q, float s);
quaternion operator*(float s, const quaternion& q);
quaternion operator/(const quaternion& q, float s);
quaternion operator/(float s, const quaternion& q);

quaternion operator+(const quaternion& q1, const quaternion& q2);
quaternion operator-(const quaternion& q1, const quaternion& q2);
quaternion operator*(const quaternion& q1, const quaternion& q2);
quaternion operator/(const quaternion& q1, const quaternion& q2);

quaternion operator*(const quaternion& q, const vector3d& v);
quaternion operator*(const vector3d& v, quaternion& q);

//Rotaciona o quatérnion q2 pelo quatérnion q1
quaternion quaternion_rotate(const quaternion& q1, const quaternion& q2);
//Rotaciona o vector3d v pelo quatérnion q
vector3d quaternion_vector_rotate(const quaternion& q, const vector3d& v);
//Constrói um quatérnion a partir de ângulos de Euler.
quaternion quaternion_from_euler_angles(float x, float y, float z);
//Extrai os ângulos de Euler do quatérnion.
vector3d quaternion_extract_euler_angles(const quaternion& q);
matrix3x3 quaternion_extract_matrix(const quaternion& q);
}
#endif



#ifndef GPP_RAY_H
#define GPP_RAY_H

namespace gpp{

bool raySphere(const vector3d& origin, const vector3d& dir, const vector3d& center, float radius, vector3d& in, vector3d& out);
bool rayBox(const vector3d& origin, const vector3d& dir, const vector3d& min, const vector3d& max, vector3d& in, vector3d& out);
bool rayCylinder(const vector3d& origin, const vector3d& dir, const vector3d& min, const vector3d& max, float radius, vector3d& in, vector3d& out);
bool rayCapsule(const vector3d& origin, const vector3d& dir, const vector3d& min, const vector3d& max, float radius, vector3d& in, vector3d& out);
}
#endif


/**
*Classe que representa um vetor 3d com os componentes x, y e z.
*Também tem sobrecargas para muitas operações.
**/
#ifndef VECTOR3D_H
#define VECTOR3D_H

#include<iostream>
namespace gpp
{

enum gpp_directions
{
gpp_invalid_dir=-1,
gpp_north=0,
gpp_northeast=45,
gpp_east=90,
gpp_southeast=135,
gpp_south=180,
gpp_southwest=225,
gpp_west=270,
gpp_northwest=315
};

class vector3d
{
public:
float x;
float y;
float z;
vector3d(float x=0.0f, float y=0.0f, float z=0.0f);
vector3d(const vector3d& dv);
vector3d& operator=(const vector3d& dv);
vector3d& operator=(const float  points[3]);
float& operator[](unsigned int index);
float operator[](unsigned int index)const;
bool operator==(const vector3d& dv)const;
bool operator==(const float dv[3])const;
vector3d& operator-();
vector3d& operator+=(float escalar);
vector3d& operator-=(float escalar);
vector3d& operator*=(float escalar);
vector3d& operator/=(float escalar);
vector3d& operator-=(const vector3d& dv);
vector3d& operator+=(const vector3d& dv);
vector3d& operator*=(const vector3d& dv);
vector3d& operator/=(const vector3d& v);
bool isNull()const;
//Calcula o comprimento, ou maguinitude do vetor...
float length()const;
//Normaliza o vetor...
vector3d& normalize();
//Inverte as propriedades do vetor...
vector3d& inverse();
//Métodos estáticos
//Usado para operações com mais de um vetor.
//Operações como produto escalar, produto cruzado e triplo produto escalar.
//Retorna um novo vetor normalizado, mantendo as propriedades originais intactas.
static vector3d normalize(const vector3d& v);
//Retorna o vetor inverso mantendo as propriedades originais.
static vector3d inverse(const vector3d& v);
//Calcula o produto escalar de 2 vetores...
static float dotProduct(const vector3d& v1, const vector3d& v2);
//Calcula o produto vetorial, ou o produto cruzado de 2 vetores...
static vector3d crossProduct(const vector3d& v1, const vector3d& v2);
//Calcula o produto triplo escalar de 3 vetores...
static float tripleProduct(const vector3d& v1, const vector3d& v2, const vector3d& v3);
//Calcula o ângulo entre 2 vetores...
static float angle_from(const vector3d& v1, const vector3d& v2);
//Calcula a distância entre 2 vetores.
static float get_distance(const vector3d& v1, const vector3d& v2);
//Retorna a distância ao quadrado entre 2 vetores.
static float get_squared_distance(const vector3d& v1, const vector3d& v2);
std::string toString()const;
};

//Sobrecarga de operadores
//As sobrecargas aqui são de multiplicação, divisão, soma e subtração.
//Também o operator<< é sobrecarregado para uso fácil com ostreams...
std::ostream& operator<<(std::ostream& os, const vector3d& dv);
vector3d operator+(const vector3d& v, float s);
vector3d operator+(float s, const vector3d& v);
vector3d operator-(const vector3d& v, float s);
vector3d operator-(float s, const vector3d& v);
vector3d operator*(const vector3d& v, float s);
vector3d operator*(float s, const vector3d& v);
vector3d operator/(const vector3d& v, float s);
vector3d operator/(float s, const vector3d& v);

vector3d operator+(const vector3d& v1, const vector3d& v2);
vector3d operator-(const vector3d& v1, const vector3d& v2);
float operator*(const vector3d& v1, const vector3d& v2);
vector3d multiVec(const vector3d& v1, const vector3d& v2);
vector3d operator/(const vector3d& v1, const vector3d& v2);
vector3d operator^(const vector3d& v1, const vector3d& v2);
}
#endif
